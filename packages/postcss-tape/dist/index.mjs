/* node:coverage disable */
import e from"node:assert/strict";import t from"fs/promises";import s from"fs";import o from"path";import n from"postcss";import i from"postcss-8.4";import r from"node:test";const noopPlugin=()=>({postcssPlugin:"noop-plugin",Rule(){}});async function fileContentsOrEmptyString(e){try{return await t.readFile(e,"utf8")}catch(e){return""}}function reduceInformationInCssSyntaxError(e){process.env.DEBUG||(delete e.source,e.input&&delete e.input.source,delete e.postcssNode)}function postcssTape(a,c){c=c??{},r("`postcss` flag is set on exported plugin creator",(()=>{e.strictEqual(a.postcss,!0)})),r("exported plugin creator is a function",(()=>{e.strictEqual(typeof a,"function")})),r("`postcssPlugin` is set on a plugin instance",(()=>{const t=a();e.ok(t.postcssPlugin),e.strictEqual(typeof t.postcssPlugin,"string")})),r("package.json",(async s=>{const o=await t.readFile("./package.json","utf-8"),n=JSON.parse(o);await s.test('includes "postcss-plugin" keyword',(()=>{e.ok(n.keywords),e.ok(n.keywords.includes("postcss-plugin"))})),await s.test('name starts with "postcss-"',{skip:c?.skipPackageNameCheck},(()=>{let t=n.name;if(t.startsWith("@")){t=n.name.split("/").slice(1).join("/")}e.ok(t.startsWith("postcss-"),`package name "${t}" does not start with "postcss-"`)})),await s.test("`postcss` is a peer dependency and not a direct dependency",{skip:"postcssTapeSelfTest"in a},(()=>{e.ok(n.peerDependencies),e.ok(Object.keys(Object(n.peerDependencies)).includes("postcss")),e.ok(!Object.keys(Object(n.dependencies)).includes("postcss"))}))}));const p=a().postcssPlugin;return async c=>{await r(p,(async r=>{for(const p in c)await r.test(p,(async r=>{const l=c[p];l.before&&await l.before();const u=o.join(".","test",...p.split(":")[0].split(o.posix.sep)),d=o.join(".","test",...p.replace(/:/g,".").split(o.posix.sep)),f="css";let m=`${u}.${f}`,g=`${d}.expect.${f}`,w=`${d}.result.${f}`;l.source&&(m=o.join(".","test",l.source)),l.expect&&(g=o.join(".","test",l.expect)),l.result&&(w=o.join(".","test",l.result));const y=l.plugins??[a(l.options)],k=await fileContentsOrEmptyString(m),S=await fileContentsOrEmptyString(g);let x,E=!1;try{x=await n(y).process(k,{from:m,to:w,map:{inline:!1,annotation:!1}})}catch(t){if(reduceInformationInCssSyntaxError(t),E=!0,l.exception&&l.exception.test(t.message))return;e.ifError(t)}e.notEqual(!E,l.exception,"expected an exception but got none");const h=x.css.toString();{const e=[t.writeFile(w,h,"utf8")];process.env.REWRITE_EXPECTS&&e.push(t.writeFile(g,h,"utf8")),await Promise.all(e)}S||e.ok(s.existsSync(g),`Missing expect file: "${g}"`),await r.test("has expected output",(()=>{e.strictEqual(h,S),e.deepStrictEqual(x.warnings().length,l.warnings??0,"Unexpected number warnings")})),await r.test("sourcemaps",(async()=>{e.ok(!x.map.toJSON().sources.includes("<no source>"),'Sourcemap is broken. This is most likely a newly created PostCSS AST Node without a value for "source". See: https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md#24-set-nodesource-for-new-nodes')})),l.after&&await l.after(),await r.test("output is parsable with PostCSS",(async()=>{const t=await fileContentsOrEmptyString(w),s=await n([noopPlugin()]).process(t,{from:w,to:w,map:{inline:!1,annotation:!1}});e.deepStrictEqual(s.warnings(),[],"Unexpected warnings on second pass")})),await r.test("The oldest and current PostCSS version produce the same result",{skip:n([noopPlugin()]).version===i([noopPlugin()]).version},(async()=>{const t=await i(y).process(k,{from:m,to:w,map:{inline:!1,annotation:!1}});e.strictEqual(t.css.toString(),h)}))}))}))}}noopPlugin.postcss=!0;const a={postcssPlugin:"declaration-cloner",Declaration(e){"to-clone"===e.prop&&e.cloneBefore({prop:"cloned"})}},c={postcssPlugin:"rule-cloner",prepare(){const e=new WeakSet;return{RuleExit(t){e.has(t)||"to-clone"===t.selector&&(e.add(t),t.cloneBefore({selector:"cloned"}))}}}},p={postcssPlugin:"at-rule-cloner",prepare(){const e=new WeakSet;return{AtRuleExit(t){if(!e.has(t))return"to-clone"===t.params?(e.add(t),void t.cloneBefore({params:"cloned"})):"to-clone"===t.name?(e.add(t),void t.cloneBefore({name:"cloned"})):void 0}}}};export{p as atRuleClonerPlugin,a as declarationClonerPlugin,postcssTape,c as ruleClonerPlugin};
/* node:coverage enable */
